use std::str::FromStr;
use std::char;
use std::path::Path;
use std::fs::File;
use std::error::Error;
use std::io::prelude::*;

use ast::Opcode;
use ast::Function;
use ast::Node;
use ast::Item;

require -> Item
    = "require" _ s:string ";" {
        let path = Path::new(&s);
        let mut file = match File::open(&path) {
            Ok(file) => file,
            Err(e) => panic!("could not open {}: {}", path.display(), e.description()),
        };
        let mut contents = String::new();
        match file.read_to_string(&mut contents) {
            Ok(_) => (),
            Err(e) => panic!("could not read {}: {}", path.display(), e.description()),
        }
        Item::Multiple(items(&contents).unwrap())
    }

pub identifier -> &'input str
    = #quiet<$([a-zA-Z_] [a-zA-Z0-9_:]*)> / #expected("identifier")

typename -> &'input str
    = #quiet<$([A-Z] [a-zA-Z0-9]*)> / #expected("typename")

pub dec_number -> u32
    = s:$([0-9] [0-9_]*) {
        let stripped = &str::replace(s, "_", "");
        u32::from_str(stripped).unwrap()
    }

pub hex_number -> u32
    = "0" [xX] s:$([0-9a-fA-F_]+) {
        let stripped = &str::replace(s, "_", "");
        u32::from_str_radix(stripped, 16).unwrap()
    }

pub number -> Box<Node>
    = u:hex_number { Box::new(Node::Number(u)) }
    / u:dec_number { Box::new(Node::Number(u)) }

pub atom -> Box<Node>
    = "(" _ v:expr _ ")" { v }
    / number
    / function
    / enum_item_inst

function -> Box<Node>
    = pattern
    / range
    / sample
    / weighted_sample

op_or  = _ "|" _
op_xor = _ "^" _
op_and = _ "&" _
op_shl = _ "<<" _
op_shr = _ ">>" _
op_add = _ "+" _
op_sub = _ "-" _
op_mul = _ "*" _
op_div = _ "/" _
op_mod = _ "%" _

pub expr -> Box<Node>
    = #infix<atom> {
        #L  x op_or  y { Box::new(Node::Operation(x, Opcode::Or, y)) }
        #L  x op_xor y { Box::new(Node::Operation(x, Opcode::Xor, y)) }
        #L  x op_and y { Box::new(Node::Operation(x, Opcode::And, y)) }
        #L  x op_shl y { Box::new(Node::Operation(x, Opcode::Shl, y)) }
            x op_shr y { Box::new(Node::Operation(x, Opcode::Shr, y)) }
        #L  x op_add y { Box::new(Node::Operation(x, Opcode::Add, y)) }
            x op_sub y { Box::new(Node::Operation(x, Opcode::Sub, y)) }
        #L  x op_mul y { Box::new(Node::Operation(x, Opcode::Mul, y)) }
            x op_div y { Box::new(Node::Operation(x, Opcode::Div, y)) }
            x op_mod y { Box::new(Node::Operation(x, Opcode::Mod, y)) }
    }

pub item -> Item
    = enum
    / assignment
    / require

pub assignment -> Item
    = lhs:identifier _ "=" _ rhs:expr _ ";" {
        Item::Single(
            Box::new(Node::Assignment(
                Box::new(Node::Identifier(lhs.into())),
                rhs
            ))
        )
    }

pub items -> Vec<Item>
    = _ a:item ** _ _ { a }

enum -> Item
    = "enum" _ id:typename _ "{" _ enum_items:enum_item ** _ _ "}" {
        Item::Single(
            Box::new(Node::Enum(id.into(), enum_items))
        )
    }

enum_item -> Box<Node>
    = id:typename _ "=" _ value:number _ "," {
        Box::new(
            Node::EnumItem(id.into(), value)
        )
    }

enum_item_inst -> Box<Node>
    = a:typename "::" b:typename {
        Box::new(
            Node::EnumItemInst(a.into(), b.into())
        )
    }

pattern -> Box<Node>
    = "Pattern(" _ a:expr ++ ("," _) _ ")" {
        Box::new(
            Node::Function(
                Function::Pattern,
                a
            )
        )
    }

pub range -> Box<Node>
    = "[" _ a:expr **<2, 2> ("," _) _ "]" {
        Box::new(
            Node::Function(
                Function::Range,
                a
            )
        )
    }

sample -> Box<Node>
    = "Sample(" _ a:expr ++ ("," _) _ ")" {
        Box::new(
            Node::Function(
                Function::Sample,
                a
            )
        )
    }

weighted_pair -> Box<Node>
    = a:dec_number _ ":" _ b:expr {
        Box::new(
            Node::WeightedPair(a, b)
        )
    }

weighted_sample -> Box<Node>
    = "{" _ a:weighted_pair ++ ("," _) _ "}" {
        Box::new(
            Node::Function(
                Function::WeightedSample,
                a
            )
        )
    }

// From: https://github.com/kevinmehall/rust-peg/blob/cc6a3cdebfafc670a9dffb0422709ff6d85d1207/src/grammar.rustpeg
_ = #quiet<(whitespace / eol / comment)*>

comment = singleLineComment

singleLineComment
    = "//" (!eolChar .)*

// Modeled after ECMA-262, 5th ed., 7.3.
eol
    = "\n"
    / "\r\n"
    / "\r"
    / "\u{2028}"
    / "\u{2029}"

eolChar
  = [\n\r\u{2028}\u{2029}]

// Modeled after ECMA-262, 5th ed., 7.2.
whitespace
    = [ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}] // \v\f removed

string -> String
    = string:(doubleQuotedString / singleQuotedString) { string }

doubleQuotedString -> String
    = '"' s:doubleQuotedCharacter* '"' { s.into_iter().collect() }

doubleQuotedCharacter -> char
    = simpleDoubleQuotedCharacter
    / simpleEscapeSequence
    / zeroEscapeSequence
    / hex2EscapeSequence
    / unicodeEscapeSequence
    / eolEscapeSequence

simpleDoubleQuotedCharacter -> char
    = !('"' / "\\" / eolChar) c:$. { c.chars().next().unwrap() }

singleQuotedString -> String
    = "'" s:singleQuotedCharacter* "'" { s.into_iter().collect() }

singleQuotedCharacter -> char
    = simpleSingleQuotedCharacter
    / simpleEscapeSequence
    / zeroEscapeSequence
    / hex2EscapeSequence
    / unicodeEscapeSequence
    / eolEscapeSequence

simpleSingleQuotedCharacter -> char
    = !("'" / "\\" / eolChar) c:$. { c.chars().next().unwrap() }

simpleEscapeSequence -> char
    = "\\" !(digit / "x" / "u" / eolChar) c:$(.) {
        match c.chars().next().unwrap() {
            //'b' => '\b',
            //'f' => '\f',
            'n' => '\n',
            'r' => '\r',
            't' => '\t',
            //'v' => '\v',
            x  => x
        }
    }

zeroEscapeSequence -> char
    = "\\0" !digit { 0u8 as char }

hex2EscapeSequence -> char
    = "\\x" value:$(hexDigit hexDigit) {
        char::from_u32(u32::from_str_radix(value, 16).unwrap()).unwrap()
    }

unicodeEscapeSequence -> char
    = "\\u{" value:$(hexDigit+) "}" {
        char::from_u32(u32::from_str_radix(value, 16).unwrap()).unwrap()
    }

eolEscapeSequence -> char
    = "\\" eol { '\n' }

digit
    = [0-9]

hexDigit
    = [0-9a-fA-F]
