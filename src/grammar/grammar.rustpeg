use std::str::FromStr;

use ast::Opcode;
use ast::Node;

pub identifier -> &'input str
    = $([a-zA-Z_] [a-zA-Z0-9_:]*)

pub number -> u32
    = s:$([0-9] [0-9_]*) {
        let stripped = &str::replace(s, "_", "");
        u32::from_str(stripped).unwrap()
    }

pub hex_number -> u32
    = "0" [xX] s:$([0-9a-fA-F_]+) {
        let stripped = &str::replace(s, "_", "");
        u32::from_str_radix(stripped, 16).unwrap()
    }

pub atom -> Box<Node>
    = "(" v:expr ")" { v }
    / u:hex_number { Box::new(Node::Number(u)) }
    / u:number { Box::new(Node::Number(u)) }
    / range

pub expr -> Box<Node>
    = #infix<atom> {
        #L  x "+" y { Box::new(Node::Operation(x, Opcode::Add, y)) }
            x "-" y { Box::new(Node::Operation(x, Opcode::Subtract, y)) }
        #L  x "*" y { Box::new(Node::Operation(x, Opcode::Multiply, y)) }
            x "/" y { Box::new(Node::Operation(x, Opcode::Divide, y)) }
    }

pub assignment -> Box<Node>
    = lhs:identifier "=" rhs:expr ";" {
        Box::new(Node::Assignment(
            Box::new(Node::Identifier(lhs.into())), rhs))
    }

pub assignments -> Vec<Box<Node>>
    = a:assignment ** eol { a }

pub range -> Box<Node>
    = "[" a:expr "," b:expr "]" {
        Box::new(Node::Range(a, b))
    }

// From: https://github.com/kevinmehall/rust-peg/blob/cc6a3cdebfafc670a9dffb0422709ff6d85d1207/src/grammar.rustpeg
// Modeled after ECMA-262, 5th ed., 7.3.
eol
    = "\n"
    / "\r\n"
    / "\r"
    / "\u{2028}"
    / "\u{2029}"
